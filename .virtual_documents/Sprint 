





%matplotlib inline
from pylab import *
from classy import *
from Game import Board


images=image.load_images('images/training squares/')
images=remap_targets(images,new_target_names=['blank','player1','player2'])
summary(images)


data=image.images_to_vectors(images)





C=NaiveBayes()
C.fit(data.vectors,data.targets)
print("On the full data set:",C.percent_correct(data.vectors,data.targets))


predictions=C.predict(data.vectors)
figure(figsize=(30,40))
names=[data.target_names[p] for p in predictions]

L=len(data.vectors)
num_rows=int(ceil(sqrt(L)))
num_cols=L//num_rows+1
for i in range(L): #range(len(data.vectors)):
    subplot(num_rows,num_cols,i+1)
    vector=data.vectors[i,:]
    im=vector.reshape(images.data[0].shape)
    im=im/255
    imshow(im)
    axis('off')
    
    
    if predictions[i]==data.targets[i]:
        title(predictions[i],color='green')
    else:
        title(predictions[i],color='red')
        








fname='images/board images/test9.jpg'
im=imread(fname)
figure(figsize=(4,4))
imshow(im)





square_size=50 # choose a size that works for you
import json
with open('locations.json') as json_file:
    locations = json.load(json_file)

count=0
im=imread(fname)

values=[]
for r,c in locations:
    sr=r-square_size//2
    er=sr+square_size
    sc=c-square_size//2
    ec=sc+square_size   
    subimage=im[sr:er,sc:ec,:]

    # convert the square image to a data vector for the classifier
    vector=subimage.ravel()
    prediction=C.predict(atleast_2d(vector))[0]

    values.append(prediction)

    count+=1


state=Board(4,4)
state.board=values
state





def read_state_from_file(filename):
    text=open(filename).read()
    text=text.strip()
    lines=[line.strip() for line in text.split('\n')]  # get rid of \n
    
    row=lines[0].split()
    R,C=len(lines),len(row)
    print(f"{R}x{C} board")
    state=Board(R,C)
    state.board=[int(val) for val in text.split()]  
    print(state)
    return state


def take_picture(fname):  # in jupyter have this, but don't put this on your robot!
    pass


def read_state():
    from pylab import imread,imsave
    import os

    # train the classifier
    images=image.load_images('images/training squares/',delete_alpha=True)  #<=========
    shape=images.data[0].shape[:2]
    data=image.images_to_vectors(images,verbose=True)  # train on all of them

    #classifier=kNearestNeighbor()
    classifier=NaiveBayes()
    classifier.fit(data.vectors,data.targets)


    # get the picture
    fname='current_board.jpg'              # for the robot
    fname='images/board images/test9.jpg'  # for debugging in jupyter
    take_picture(fname)
    im=imread(fname)

    # slice the picture into squares of the right size
    square_size=50 # choose a size that works for you
    import json
    with open('locations.json') as json_file:
        locations = json.load(json_file)

    count=0
    # for debugging
    if not os.path.exists('images/predicted'):
        os.mkdir('images/predicted')
    
    values=[]
    for r,c in locations:
        sr=r-square_size//2
        er=sr+square_size
        sc=c-square_size//2
        ec=sc+square_size   
        subimage=im[sr:er,sc:ec,:]
    
        # convert the square image to a data vector for the classifier
        vector=subimage.ravel()
        prediction=C.predict(atleast_2d(vector))[0]
    
        values.append(prediction)

        # for debugging
        imsave('images/predicted/square %d predicted as %s.jpg' % (count,data.target_names[prediction]),subimage)
    
        count+=1

    
    # reconstruct the state from the predictions
    state=Board(4,4)                                      #<========= change the size
    state.board=values

    print("Current state is:")
    print(state)

    x=input("""
    Hit return if this is correct, otherwise type a character 
    and the state will be read from current_board.txt.""")

    if x:
        print("Reading from file...")
        state=read_state_from_file('board.txt')

    print("Using")
    print(state)

    
    return state



state=read_state()



